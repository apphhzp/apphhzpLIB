package apphhzp.lib.hotspot.util;

public interface ClassConstants {
    // constant pool constant types - from JVM spec.

    int JVM_CONSTANT_Utf8               = 1;
    int JVM_CONSTANT_Unicode            = 2; // unused
    int JVM_CONSTANT_Integer            = 3;
    int JVM_CONSTANT_Float              = 4;
    int JVM_CONSTANT_Long               = 5;
    int JVM_CONSTANT_Double             = 6;
    int JVM_CONSTANT_Class              = 7;
    int JVM_CONSTANT_String             = 8;
    int JVM_CONSTANT_Fieldref           = 9;
    int JVM_CONSTANT_Methodref          = 10;
    int JVM_CONSTANT_InterfaceMethodref = 11;
    int JVM_CONSTANT_NameAndType        = 12;
    int JVM_CONSTANT_MethodHandle       = 15;
    int JVM_CONSTANT_MethodType         = 16;
    int JVM_CONSTANT_Dynamic            = 17;
    int JVM_CONSTANT_InvokeDynamic      = 18;
    int JVM_CONSTANT_Module             = 19;
    int JVM_CONSTANT_Package            = 20;

    // JVM_CONSTANT_MethodHandle subtypes
    int JVM_REF_getField                = 1;
    int JVM_REF_getStatic               = 2;
    int JVM_REF_putField                = 3;
    int JVM_REF_putStatic               = 4;
    int JVM_REF_invokeVirtual           = 5;
    int JVM_REF_invokeStatic            = 6;
    int JVM_REF_invokeSpecial           = 7;
    int JVM_REF_newInvokeSpecial        = 8;
    int JVM_REF_invokeInterface         = 9;

    // HotSpot specific constant pool constant types.

    // For bad value initialization
    int JVM_CONSTANT_Invalid            = 0;

    int JVM_CONSTANT_UnresolvedClass          = 100;  // Temporary tag until actual use
    int JVM_CONSTANT_ClassIndex               = 101;  // Temporary tag while constructing constant pool
    int JVM_CONSTANT_StringIndex              = 102;  // Temporary tag while constructing constant pool
    int JVM_CONSTANT_UnresolvedClassInError   = 103;  // Error tag due to resolution error
    int JVM_CONSTANT_MethodHandleInError      = 104;  // Error tag due to resolution error
    int JVM_CONSTANT_MethodTypeInError        = 105;  // Error tag due to resolution error

    // 1.5 major/minor version numbers from JVM spec. 3rd edition
    short MAJOR_VERSION = 49;
    short MINOR_VERSION = 0;

    short MAJOR_VERSION_OLD = 46;
    short MINOR_VERSION_OLD = 0;

    // From jvm.h
    int JVM_ACC_PUBLIC       = 0x0001; /* visible to everyone */
    int JVM_ACC_PRIVATE      = 0x0002; /* visible only to the defining class */
    int JVM_ACC_PROTECTED    = 0x0004; /* visible to subclasses */
    int JVM_ACC_STATIC       = 0x0008; /* instance variable is static */
    int JVM_ACC_FINAL        = 0x0010; /* no further subclassing, overriding */
    int JVM_ACC_SYNCHRONIZED = 0x0020; /* wrap method call in monitor lock */
    int JVM_ACC_SUPER        = 0x0020; /* funky handling of invokespecial */
    int JVM_ACC_VOLATILE     = 0x0040; /* can not cache in registers */
    int JVM_ACC_BRIDGE       = 0x0040; /* bridge method generated by compiler */
    int JVM_ACC_TRANSIENT    = 0x0080; /* not persistant */
    int JVM_ACC_VARARGS      = 0x0080; /* method declared with variable number of args */
    int JVM_ACC_NATIVE       = 0x0100; /* implemented in C */
    int JVM_ACC_INTERFACE    = 0x0200; /* class is an interface */
    int JVM_ACC_ABSTRACT     = 0x0400; /* no definition provided */
    int JVM_ACC_STRICT       = 0x0800; /* strict floating point */
    int JVM_ACC_SYNTHETIC    = 0x1000; /* compiler-generated class, method or field */
    int JVM_ACC_ANNOTATION   = 0x2000; /* annotation type */
    int JVM_ACC_ENUM         = 0x4000; /* field is declared as element of enum */
    int JVM_ACC_MODULE        = 0x8000;

    // from accessFlags.hpp - hotspot internal flags

    // flags actually put in .class file
    int JVM_ACC_WRITTEN_FLAGS = 0x00007FFF;

    // Method* flags
    // monitorenter/monitorexit bytecodes match
    int JVM_ACC_MONITOR_MATCH = 0x10000000;
    // Method contains monitorenter/monitorexit bytecodes
    int JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000;
    // Method has loops
    int JVM_ACC_HAS_LOOPS             = 0x40000000;
    // The loop flag has been initialized
    int JVM_ACC_LOOPS_FLAG_INIT       = (int)0x80000000;
    // Queued for compilation
    int JVM_ACC_QUEUED                = 0x01000000;
    // TEMPORARY: currently on stack replacement compilation is not built into the
    // invocation counter machinery.  Until it is, we will keep track of methods which
    // cannot be on stack replaced in the access flags.
    int JVM_ACC_NOT_OSR_COMPILABLE     = 0x08000000;
    int JVM_ACC_HAS_LINE_NUMBER_TABLE  = 0x00100000;
    int JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000;
    int JVM_ACC_HAS_JSRS               = 0x00800000;
    // RedefineClasses() has made method obsolete
    int JVM_ACC_IS_OBSOLETE            = 0x00010000;

    // Klass* flags
    // True if this class has miranda methods in it's vtable
    int JVM_ACC_HAS_MIRANDA_METHODS      = 0x10000000;
    // True if klass has a vanilla default constructor
    int JVM_ACC_HAS_VANILLA_CONSTRUCTOR  = 0x20000000;
    // True if klass has a non-empty finalize() method
    int JVM_ACC_HAS_FINALIZER            = 0x40000000;
    // True if klass supports the Clonable interface
    int JVM_ACC_IS_CLONEABLE             =(int) 0x80000000;

    // Klass* and Method* flags
    int JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000;
    // flags promoted from methods to the holding klass
    int JVM_ACC_PROMOTED_FLAGS           = 0x00200000;

    // field flags
    // Note: these flags must be defined in the low order 16 bits because
    // InstanceKlass only stores a ushort worth of information from the
    // AccessFlags value.
    // field access is watched by JVMTI
    int JVM_ACC_FIELD_ACCESS_WATCHED         = 0x00002000;
    // field modification is watched by JVMTI
    int JVM_ACC_FIELD_MODIFICATION_WATCHED   = 0x00008000;
    // field has generic signature
    int JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE  = 0x00000800;

    // flags accepted by set_field_flags
    int JVM_ACC_FIELD_FLAGS = 0x00008000 | JVM_ACC_WRITTEN_FLAGS;

    // from jvm.h

    int JVM_RECOGNIZED_CLASS_MODIFIERS   = (JVM_ACC_PUBLIC |
            JVM_ACC_FINAL |
            JVM_ACC_SUPER |
            JVM_ACC_INTERFACE |
            JVM_ACC_ABSTRACT |
            JVM_ACC_ANNOTATION |
            JVM_ACC_ENUM |
            JVM_ACC_SYNTHETIC);


    int JVM_RECOGNIZED_FIELD_MODIFIERS  = (JVM_ACC_PUBLIC |
            JVM_ACC_PRIVATE |
            JVM_ACC_PROTECTED |
            JVM_ACC_STATIC |
            JVM_ACC_FINAL |
            JVM_ACC_VOLATILE |
            JVM_ACC_TRANSIENT |
            JVM_ACC_ENUM |
            JVM_ACC_SYNTHETIC);

    int JVM_RECOGNIZED_METHOD_MODIFIERS  = (JVM_ACC_PUBLIC |
            JVM_ACC_PRIVATE |
            JVM_ACC_PROTECTED |
            JVM_ACC_STATIC |
            JVM_ACC_FINAL |
            JVM_ACC_SYNCHRONIZED |
            JVM_ACC_BRIDGE |
            JVM_ACC_VARARGS |
            JVM_ACC_NATIVE |
            JVM_ACC_ABSTRACT |
            JVM_ACC_STRICT |
            JVM_ACC_SYNTHETIC);
}

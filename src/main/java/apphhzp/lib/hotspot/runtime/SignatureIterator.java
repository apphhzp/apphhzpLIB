package apphhzp.lib.hotspot.runtime;

import apphhzp.lib.hotspot.oops.Symbol;
import apphhzp.lib.hotspot.util.RawCType;
import apphhzp.lib.hotspot.utilities.BasicType;

import java.util.function.IntConsumer;

import static apphhzp.lib.helfy.JVM.BitsPerLong;
import static apphhzp.lib.helfy.JVM.right_n_bits;


/** A SignatureIterator uses a SignatureStream to produce BasicType results, discarding class names.
 *  This means it can be accelerated using a fingerprint mechanism, in many cases, without loss of type information.
 *  The FingerPrinter class computes and caches this reduced information for faster iteration.*/
public class SignatureIterator {
    /** Definitions used in generating and iterating the bit field form of the signature generated by the Fingerprinter.*/
    public static final int
        fp_static_feature_size    = 1,
                fp_is_static_bit          = 1,

                fp_result_feature_size    = 4,
                fp_result_feature_mask    = right_n_bits(fp_result_feature_size),
                fp_parameter_feature_size = 4,
                fp_parameter_feature_mask = right_n_bits(fp_parameter_feature_size),

                fp_parameters_done        = 0,  // marker for end of parameters (must be zero)

                // Parameters take up full wordsize, minus the result and static bit fields.
                // Since fp_parameters_done is zero, termination field arises from shifting
                // in zero bits, and therefore occupies no extra space.
                // The sentinel value is all-zero-bits, which is impossible for a true
                // fingerprint, since at least the result field will be non-zero.
                fp_max_size_of_parameters = ((BitsPerLong
                        - (fp_result_feature_size + fp_static_feature_size))
                        / fp_parameter_feature_size);

    protected Symbol      _signature;             // the signature to iterate over
    protected @RawCType("BasicType") int _return_type;
    protected @RawCType("uint64_t") long _fingerprint;

    public static @RawCType("uint64_t") long zero_fingerprint() { return 0; }
    public static @RawCType("uint64_t") long overflow_fingerprint() {
        return -1L;
    }
    public static boolean fp_is_valid(@RawCType("uint64_t") long fingerprint) {
        return (fingerprint != zero_fingerprint()) && (fingerprint != overflow_fingerprint());
    }

    public static boolean fp_is_valid_type(@RawCType("BasicType")int type){
        return fp_is_valid_type(type,false);
    }

    public static boolean fp_is_valid_type(@RawCType("BasicType")int type, boolean for_return_type){
        if (type == fp_parameters_done){
            throw new RuntimeException("fingerprint is incorrectly at done");
        }
        if (!((type & ~fp_parameter_feature_mask) == 0)){
            throw new RuntimeException("fingerprint feature mask yielded non-zero value");
        }
        return (BasicType.is_java_primitive(type) ||
                BasicType.is_reference_type(type) ||
                (for_return_type && type == BasicType.T_VOID));
    }

    // Constructors
    public SignatureIterator(Symbol signature) {
        this(signature,zero_fingerprint());
    }
    public SignatureIterator(Symbol signature, @RawCType("uint64_t") long fingerprint) {
        _signature   = signature;
        _return_type = BasicType.T_ILLEGAL;  // sentinel value for uninitialized
        _fingerprint = zero_fingerprint();
        if (fingerprint != _fingerprint) {
            set_fingerprint(fingerprint);
        }
    }

    public void set_fingerprint(@RawCType("uint64_t") long fingerprint) {
        if (!fp_is_valid(fingerprint)) {
            _fingerprint = fingerprint;
            _return_type = BasicType.T_ILLEGAL;
        } else if (fingerprint != _fingerprint) {
            if (_fingerprint != zero_fingerprint()){
                throw new IllegalArgumentException("consistent fingerprint values");
            }
            _fingerprint = fingerprint;
            _return_type = fp_return_type(fingerprint);
        }
    }

    // Returns the set fingerprint, or zero_fingerprint()
    // if none has been set already.
    public @RawCType("uint64_t") long fingerprint(){
        return _fingerprint;
    }

    // Iteration
    /** Hey look:  There are no virtual methods in this class.
     * So how is it customized?  By calling do_parameters_on an object which answers to "do_type(BasicType)".
     * By convention, this object is in the subclass itself, so the call is "do_parameters_on(this)".
     * The effect of this is to inline the parsing loop everywhere "do_parameters_on" is called.
     * If there is a valid fingerprint in the object, an improved loop is called which just unpacks the bitfields from the fingerprint.
     * Otherwise, the symbol is parsed.*/
    public <T extends SignatureIterator> void do_parameters_on(T callback){
        do_parameters_on((IntConsumer) callback::do_type);
    }

    public void do_parameters_on(IntConsumer callback){
        @RawCType("uint64_t") long unaccumulator = _fingerprint;
        // Check for too many arguments, or missing fingerprint:
        if (!fp_is_valid(unaccumulator)) {
            SignatureStream ss=new SignatureStream(_signature);
            for (; !ss.at_return_type(); ss.next()) {
                callback.accept(ss.type());
            }
            // while we are here, capture the return type
            _return_type = ss.type();
        } else {
            // Optimized version of do_parameters when fingerprint is known
            if (_return_type == BasicType.T_ILLEGAL){
                throw new RuntimeException("return type already captured from fp");
            }
            unaccumulator = fp_start_parameters(unaccumulator);
            long[] arr=new long[]{0};
            for (@RawCType("BasicType")int type; (type = fp_next_parameter(unaccumulator,arr)) != fp_parameters_done; unaccumulator=arr[0]){
                if (!fp_is_valid_type(type)){
                    throw new RuntimeException("garbled fingerprint");
                }
                callback.accept(type);
            }
        }
    }

    public @RawCType("BasicType") int return_type() {// computes the value on the fly if necessary
        if (_return_type == BasicType.T_ILLEGAL) {
            SignatureStream ss=new SignatureStream(_signature);
            ss.skip_to_return_type();
            _return_type = ss.type();
            if (_return_type == BasicType.T_ILLEGAL){
                throw new RuntimeException("illegal return type");
            }
        }
        return _return_type;
    }

    public static boolean fp_is_static(@RawCType("uint64_t") long fingerprint) {
        if (!fp_is_valid(fingerprint)){
            throw new IllegalArgumentException("invalid fingerprint");
        }
        return (fingerprint & fp_is_static_bit)!=0;
    }
    public static @RawCType("BasicType") int fp_return_type(@RawCType("uint64_t") long fingerprint) {
        if (!fp_is_valid(fingerprint)){
            throw new IllegalArgumentException("invalid fingerprint");
        }
        return (int) ((fingerprint >>> fp_static_feature_size) & fp_result_feature_mask);
    }
    public static @RawCType("uint64_t") long fp_start_parameters(@RawCType("uint64_t") long fingerprint) {
        if (!fp_is_valid(fingerprint)){
            throw new IllegalArgumentException("invalid fingerprint");
        }
        return fingerprint >>> (fp_static_feature_size + fp_result_feature_size);
    }
    public static @RawCType("BasicType") int fp_next_parameter(@RawCType("uint64_t&") long mask,long[] newMask) {
        int result = (int) (mask & fp_parameter_feature_mask);
        mask >>>= fp_parameter_feature_size;
        newMask[0]=mask;
        return result;
    }

    protected void do_type(int type){
        throw new UnsupportedOperationException("Should be overridden");
    }
}
